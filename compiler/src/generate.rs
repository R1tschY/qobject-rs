use crate::ffi::{FfiBridge, FfiFunction};
use crate::qobject::{Include, QObjectConfig, QObjectMethod, QObjectProp, QObjectSignal, TypeRef};
use std::borrow::Cow;
use std::collections::HashSet;
use std::iter::FromIterator;

pub trait Dependent {
    fn dependencies(&self, includes: &mut HashSet<Include>);
}

impl Dependent for QObjectProp {
    fn dependencies(&self, includes: &mut HashSet<Include>) {
        if let Some(include) = self.type_ref.include() {
            includes.insert(include.clone());
        }
    }
}

impl Dependent for QObjectMethod {
    fn dependencies(&self, includes: &mut HashSet<Include>) {
        if let Some(rtype) = &self.rtype {
            if let Some(include) = rtype.include() {
                includes.insert(include.clone());
            }
        }
        includes.extend(self.args.iter().flat_map(|(_, ty)| ty.include().clone()));
    }
}

impl Dependent for QObjectSignal {
    fn dependencies(&self, includes: &mut HashSet<Include>) {
        includes.extend(self.args.iter().flat_map(|(_, ty)| ty.include().clone()));
    }
}

impl Dependent for QObjectConfig {
    fn dependencies(&self, includes: &mut HashSet<Include>) {
        self.properties
            .iter()
            .for_each(|p| p.dependencies(includes));
        self.methods.iter().for_each(|p| p.dependencies(includes));
        self.signals.iter().for_each(|p| p.dependencies(includes));
        if let Some(include) = self.base_class.include() {
            includes.insert(include.clone());
        }
    }
}

trait GenerateCode: Dependent {
    fn fill_ffi_functions(&self, ffi: &mut FfiBridge);
    fn generate_forward_definitions(&self, lines: &mut Vec<Cow<str>>);
    fn generate_classes(&self, lines: &mut Vec<Cow<str>>);
    fn generate_implementations(&self, lines: &mut Vec<Cow<str>>);
}

fn generate_include(include: &Include) -> String {
    match include {
        Include::System(include) => format!("#include <{}>", include),
        Include::Relative(include) => format!("#include \"{}\"", include),
    }
}

fn generate_base_function_def(
    name: &str,
    args: &Vec<(String, TypeRef)>,
    rtype: &Option<TypeRef>,
) -> String {
    format!(
        "{} {}({})",
        rtype
            .as_ref()
            .map(|rt| rt.name().clone())
            .unwrap_or("void".into()),
        name,
        args.iter()
            .map(|(name, ty)| format!("{} {}", name, ty.name()))
            .collect::<Vec<String>>()
            .join(", "),
    )
}

fn generate_prop_def(prop: &QObjectProp) -> String {
    let read = prop
        .getter
        .as_ref()
        .map(|getter| format!(" READ {}", getter))
        .unwrap_or(String::new());
    let write = prop
        .setter
        .as_ref()
        .map(|setter| format!(" WRITE {}", setter))
        .unwrap_or(String::new());
    let notify = prop
        .signal
        .as_ref()
        .map(|signal| format!(" NOTIFY {}", signal))
        .unwrap_or(String::new());
    let const_ = if prop.const_ { " CONST" } else { "" };

    format!(
        "  Q_PROPERTY({} {}{}{}{}{});",
        prop.type_ref.name(),
        prop.name,
        read,
        write,
        notify,
        const_
    )
}

fn generate_method_impl(meth: &QObjectMethod) -> String {
    let scriptable = if meth.scriptable { "Q_SCRIPTABLE " } else { "" };
    let const_ = if meth.const_ { " const" } else { "" };
    let override_ = if meth.override_ { " override" } else { "" };

    format!(
        "  {}{}{}{} {{\n    {}\n  }}",
        scriptable,
        generate_base_function_def(&meth.name, &meth.args, &meth.rtype),
        const_,
        override_,
        generate_ffi_impl(meth),
    )
}

fn generate_ffi_impl(meth: &QObjectMethod) -> String {
    let mut params: Vec<String> = meth
        .args
        .iter()
        .map(|arg| format!("std::forward<{}>({})", arg.1.name(), arg.0))
        .collect();
    params.insert(0, "_d".into());
    if let Some(rty) = &meth.rtype {
        params.push("&out__".into());
        format!(
            "{} out__;\n    {}({});\n    return out__;",
            rty.name(),
            meth.ffi_name,
            params.join(", ")
        )
    } else {
        format!("    {}({});", meth.ffi_name, params.join(", "))
    }
}

fn generate_signal(signal: &QObjectSignal) -> String {
    format!(
        "  {};",
        generate_base_function_def(&signal.name, &signal.args, &None),
    )
}

pub fn generate_translation_unit(moc_name: &str, objects: &[&QObjectConfig]) -> String {
    let mut lines: Vec<Cow<str>> = vec![];
    let mut ffi = FfiBridge::new();
    for obj in objects {
        obj.fill_ffi_functions(&mut ffi);
    }

    lines.push("// Generated by qobject compiler".into());
    lines.push("".into());

    let mut includes = HashSet::new();
    for obj in objects {
        obj.dependencies(&mut includes);
    }
    let mut includes = Vec::from_iter(includes.into_iter());
    includes.sort();
    lines.extend(includes.iter().map(|i| generate_include(i).into()));

    lines.push("".into());
    for obj in objects {
        obj.generate_forward_definitions(&mut lines);
    }
    for function in &ffi.functions {
        lines.push(function.generate_ffi_def().into());
    }

    lines.push("".into());
    for obj in objects {
        obj.generate_classes(&mut lines);
    }

    lines.push("".into());
    for obj in objects {
        obj.generate_implementations(&mut lines);
    }

    lines.push(format!("#include \"{}\"", moc_name).into());
    lines.join("\n")
}

impl GenerateCode for QObjectConfig {
    fn fill_ffi_functions(&self, ffi: &mut FfiBridge) {
        for meth in &self.methods {
            let mut args = meth.args.clone();
            args.insert(0, ("self_".into(), TypeRef::void_ptr()));
            ffi.function(FfiFunction::new_complete(
                &meth.ffi_name,
                args,
                meth.rtype.clone(),
            ));
        }
        ffi.function(FfiFunction::new_complete(
            &format!("Qffi_{}_new", self.name),
            vec![("qobject".into(), TypeRef::qobject_ptr())],
            Some(TypeRef::void_ptr()),
        ));
        ffi.function(FfiFunction::new_complete(
            &format!("Qffi_{}_delete", self.name),
            vec![("self_".into(), TypeRef::void_ptr())],
            None,
        ));
    }

    fn generate_forward_definitions(&self, lines: &mut Vec<Cow<str>>) {
        lines.push(format!("class {};", self.name).into());
    }

    fn generate_classes(&self, lines: &mut Vec<Cow<str>>) {
        lines.push(format!("class {} : public {} {{", self.name, self.base_class.name()).into());
        lines.push("  Q_OBJECT".into());
        lines.extend(
            self.properties
                .iter()
                .map(|prop| generate_prop_def(prop).into()),
        );
        lines.push("".into());
        lines.push("public:".into());
        lines.push(
            format!(
                "  {}(QObject* parent = nullptr) : QObject(parent) {{ this._d = Qffi_{}_new(this); }}",
                self.name, self.name
            )
            .into(),
        );
        lines.push(
            format!(
                "  ~{}() {{ Qffi_{}_delete(this._d); }}",
                self.name, self.name
            )
            .into(),
        );
        lines.push("".into());
        lines.extend(
            self.methods
                .iter()
                .map(|meth| generate_method_impl(meth).into()),
        );
        lines.push("".into());
        lines.push("Q_SIGNALS:".into());
        lines.extend(
            self.signals
                .iter()
                .map(|signal| generate_signal(signal).into()),
        );
        lines.push("".into());
        lines.push("private:".into());
        lines.push("  void* _d;".into());
        lines.push("};".into());
    }

    fn generate_implementations(&self, _lines: &mut Vec<Cow<str>>) {}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_simple_class() {
        let obj = QObjectConfig::new("Dummy");
        let obj_clone = obj.clone();
        let obj = obj
            .inherit(TypeRef::qtobject("QObject"))
            .property(QObjectProp::new_readonly(
                &TypeRef::qstring(),
                "dummy",
                "dummy",
                "dummyChanged",
            ))
            .method(QObjectMethod::new(&obj_clone, "dummy").ret(&TypeRef::qstring()))
            .signal(QObjectSignal::new("dummyChanged"));
        let code = generate_translation_unit("dummy.moc", &[&obj]);

        println!("{}", code);

        assert!(code.contains("#include <QObject>"));
        assert!(code.contains("#include <QString>"));
        assert!(code.contains("Q_OBJECT"));
        assert!(code.contains("Q_PROPERTY(QString dummy READ dummy NOTIFY dummyChanged);"));
        assert!(code.contains("class Dummy : public QObject"));
        assert!(code.contains("QString dummy()"));
        assert!(code.contains("void dummyChanged();"));
        assert!(code.contains("#include \"dummy.moc\""));
        assert!(code.contains("Qffi_Dummy_dummy(_d, &out__);"));
        assert!(code.contains("void Qffi_Dummy_dummy(void* self_, QString* out__);"));
        assert!(code.contains("void* Qffi_Dummy_new(QObject* qobject);"));
        assert!(code.contains("void Qffi_Dummy_delete(void* self_);"));
    }

    #[test]
    fn test_cpp_impl() {
        let def = generate_ffi_impl(
            &QObjectMethod::new(&QObjectConfig::new("Test"), "test")
                .arg("arg0", &TypeRef::qtobject("CppType0"))
                .arg("arg1", &TypeRef::qtobject("CppType1")),
        );
        assert_eq!(
            "    Qffi_Test_test(_d, std::forward<CppType0>(arg0), std::forward<CppType1>(arg1));",
            def
        );
    }

    #[test]
    fn test_cpp_impl_with_return() {
        let def = generate_ffi_impl(
            &QObjectMethod::new(&QObjectConfig::new("Test"), "test")
                .arg("arg0", &TypeRef::qtobject("CppType0"))
                .ret(&TypeRef::qtobject("RetCppType")),
        );
        assert_eq!(
            r#"
    RetCppType out__;
    Qffi_Test_test(_d, std::forward<CppType0>(arg0), &out__);
    return out__;"#
                .trim(),
            def.trim()
        );
    }
}
