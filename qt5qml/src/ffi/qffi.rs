/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
#[repr(C)]
pub struct QList {
    pub _address: u8,
}
#[repr(C)]
pub struct QMetaObject {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QString {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QByteArray {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QUrl {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QObject {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QGenericArgument {
    pub data: *const ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
pub struct QGenericReturnArgument {
    pub data: *const ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
pub struct QMetaMethod {
    pub __mobj: *const QMetaObject,
    pub __handle: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct QMetaEnum {
    pub __mobj: *const QMetaObject,
    pub __handle: ::std::os::raw::c_uint,
}
#[repr(C)]
pub struct QMetaProperty {
    pub __mobj: *const QMetaObject,
    pub __handle: ::std::os::raw::c_uint,
    pub __idx: ::std::os::raw::c_int,
    pub __menum: QMetaEnum,
}
#[repr(C)]
pub struct QMetaObjectConnection {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QVariant {
    pub data: QVariant__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
pub struct QVariant__bindgen_ty_1 {
    pub c: __BindgenUnionField<::std::os::raw::c_char>,
    pub uc: __BindgenUnionField<::std::os::raw::c_uchar>,
    pub s: __BindgenUnionField<::std::os::raw::c_short>,
    pub sc: __BindgenUnionField<::std::os::raw::c_schar>,
    pub us: __BindgenUnionField<::std::os::raw::c_ushort>,
    pub i: __BindgenUnionField<::std::os::raw::c_int>,
    pub u: __BindgenUnionField<::std::os::raw::c_uint>,
    pub l: __BindgenUnionField<::std::os::raw::c_long>,
    pub ul: __BindgenUnionField<::std::os::raw::c_ulong>,
    pub b: __BindgenUnionField<bool>,
    pub d: __BindgenUnionField<f64>,
    pub f: __BindgenUnionField<f32>,
    pub ll: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub ull: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
impl QVariant {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn is_shared(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_shared(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_null(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_null(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_uint,
        is_shared: ::std::os::raw::c_uint,
        is_null: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_shared: u32 = unsafe { ::std::mem::transmute(is_shared) };
            is_shared as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_null: u32 = unsafe { ::std::mem::transmute(is_null) };
            is_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct QTimer {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QCoreApplication {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QGuiApplication {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QHashIntQByteArray {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QThread {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QQmlEngine {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QQmlApplicationEngine {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct QObjectList {
    pub __d: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct QStringList {
    pub __d: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn qffi_QString_init(self_: *mut QString);
}
extern "C" {
    pub fn qffi_QString_clone(self_: *const QString, new_: *mut QString);
}
extern "C" {
    pub fn qffi_QString_equals(self_: *const QString, other: *const QString) -> bool;
}
extern "C" {
    pub fn qffi_QString_size(self_: *const QString) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QString_isNull(self_: *const QString) -> bool;
}
extern "C" {
    pub fn qffi_QString_fromUtf8(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        result: *mut QString,
    );
}
extern "C" {
    pub fn qffi_QString_fromUtf16(
        data: *const ::std::os::raw::c_ushort,
        size: ::std::os::raw::c_int,
        result: *mut QString,
    );
}
extern "C" {
    pub fn qffi_QString_fromUtf16Unchecked(
        data: *const ::std::os::raw::c_ushort,
        size: ::std::os::raw::c_int,
        result: *mut QString,
    );
}
extern "C" {
    pub fn qffi_QString_toUtf8(self_: *const QString, result: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QString_utf16(
        self_: *const QString,
        len: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn qffi_QString_compare(
        self_: *const QString,
        other: *const QString,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QByteArray_init(self_: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QByteArray_clone(self_: *const QByteArray, new_: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QByteArray_equals(self_: *const QByteArray, other: *const QByteArray) -> bool;
}
extern "C" {
    pub fn qffi_QByteArray_fromData(
        data: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut QByteArray,
    );
}
extern "C" {
    pub fn qffi_QByteArray_data(
        self_: *const QByteArray,
        len: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn qffi_QByteArray_compare(
        self_: *const QByteArray,
        other: *const QByteArray,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QUrl_init(self_: *mut QUrl);
}
extern "C" {
    pub fn qffi_QUrl_clone(self_: *const QUrl, new_: *mut QUrl);
}
extern "C" {
    pub fn qffi_QUrl_equals(self_: *const QUrl, other: *const QUrl) -> bool;
}
extern "C" {
    pub fn qffi_QUrl_cmp(self_: *const QUrl, other: *const QUrl) -> ::std::os::raw::c_schar;
}
extern "C" {
    pub fn qffi_QUrl_fromString(value: *const QString, result: *mut QUrl);
}
extern "C" {
    pub fn qffi_QUrl_fromLocalFile(value: *const QString, result: *mut QUrl);
}
extern "C" {
    pub fn qffi_QUrl_debug(self_: *const QUrl, out: *mut QString);
}
extern "C" {
    pub fn qffi_QObject_init(parent: *mut QObject) -> *mut QObject;
}
extern "C" {
    pub fn qffi_QObject_inherits(
        self_: *const QObject,
        class_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QObject_deleteLater(self_: *mut QObject);
}
extern "C" {
    pub fn qffi_QObject_metaObject(self_: *const QObject) -> *const QMetaObject;
}
extern "C" {
    pub fn qffi_QObject_moveToThread(self_: *mut QObject, targetThread: *mut QThread);
}
extern "C" {
    pub fn qffi_QObject_connect(
        self_: *const QObject,
        signal: *const ::std::os::raw::c_char,
        receiver: *const QObject,
        method: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        result: *mut QMetaObjectConnection,
    );
}
extern "C" {
    pub fn qffi_QObject_disconnectConnection(connection: *const QMetaObjectConnection) -> bool;
}
extern "C" {
    pub fn qffi_QObject_disconnect2(
        self_: *const QObject,
        receiver: *const QObject,
        method: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QObject_disconnect3(
        self_: *const QObject,
        signal: *const ::std::os::raw::c_char,
        receiver: *const QObject,
        method: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QObject_destroy(self_: *mut QObject);
}
extern "C" {
    pub fn qffi_QMetaObject_className(self_: *const QMetaObject) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn qffi_QMetaObject_propertyCount(self_: *const QMetaObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QMetaObject_propertyOffset(self_: *const QMetaObject) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QMetaObject_property(
        self_: *const QMetaObject,
        index: ::std::os::raw::c_int,
    ) -> QMetaProperty;
}
extern "C" {
    pub fn qffi_QMetaObject_invokeMethod(
        obj: *mut QObject,
        member: *const ::std::os::raw::c_char,
        ty: ::std::os::raw::c_int,
        args: *const QGenericArgument,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QMetaObject_invokeMethodAndReturn(
        obj: *mut QObject,
        member: *const ::std::os::raw::c_char,
        ty: ::std::os::raw::c_int,
        ret: *const QGenericReturnArgument,
        args: *const QGenericArgument,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QMetaMethod_init(self_: *mut QMetaMethod);
}
extern "C" {
    pub fn qffi_QMetaMethod_destroy(self_: *mut QMetaMethod);
}
extern "C" {
    pub fn qffi_QMetaMethod_equals(self_: *const QMetaMethod, other: *const QMetaMethod) -> bool;
}
extern "C" {
    pub fn qffi_QMetaEnum_init(self_: *mut QMetaEnum);
}
extern "C" {
    pub fn qffi_QMetaProperty_init(self_: *mut QMetaProperty);
}
extern "C" {
    pub fn qffi_QMetaProperty_destroy(self_: *mut QMetaProperty);
}
extern "C" {
    pub fn qffi_QMetaProperty_hasNotifySignal(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isConstant(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isDesignable(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isEnumType(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isFinal(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isFlagType(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isReadable(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isResettable(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isScriptable(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isStored(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isUser(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_isWritable(self_: *const QMetaProperty) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_name(self_: *const QMetaProperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn qffi_QMetaProperty_notifySignal(self_: *const QMetaProperty) -> QMetaMethod;
}
extern "C" {
    pub fn qffi_QMetaProperty_notifySignalIndex(
        self_: *const QMetaProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QMetaProperty_propertyIndex(self_: *const QMetaProperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QMetaProperty_read(
        self_: *const QMetaProperty,
        object: *const QObject,
        result: *mut QVariant,
    );
}
extern "C" {
    pub fn qffi_QMetaProperty_readOnGadget(
        self_: *const QMetaProperty,
        gadget: *const ::std::os::raw::c_void,
        result: *mut QVariant,
    );
}
extern "C" {
    pub fn qffi_QMetaProperty_reset(self_: *const QMetaProperty, object: *mut QObject) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_resetOnGadget(
        self_: *const QMetaProperty,
        gadget: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_revision(self_: *const QMetaProperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QMetaProperty_typeName(
        self_: *const QMetaProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn qffi_QMetaProperty_write(
        self_: *const QMetaProperty,
        object: *mut QObject,
        value: *const QVariant,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QMetaProperty_writeOnGadget(
        self_: *const QMetaProperty,
        gadget: *mut ::std::os::raw::c_void,
        value: *const QVariant,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QMetaObjectConnection_init(self_: *mut QMetaObjectConnection);
}
extern "C" {
    pub fn qffi_QMetaObjectConnection_clone(
        self_: *const QMetaObjectConnection,
        new_: *mut QMetaObjectConnection,
    );
}
extern "C" {
    pub fn qffi_QMetaObjectConnection_isValid(self_: *const QMetaObjectConnection) -> bool;
}
extern "C" {
    pub fn qffi_QVariant_init(self_: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_clone(self_: *const QVariant, new_: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_equals(self_: *const QVariant, other: *const QVariant) -> bool;
}
extern "C" {
    pub fn qffi_QVariant_cmp(
        self_: *const QVariant,
        other: *const QVariant,
    ) -> ::std::os::raw::c_schar;
}
extern "C" {
    pub fn qffi_QVariant_isValid(self_: *const QVariant) -> bool;
}
extern "C" {
    pub fn qffi_QVariant_isNull(self_: *const QVariant) -> bool;
}
extern "C" {
    pub fn qffi_QVariant_from_int(value: ::std::os::raw::c_int, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_uint(value: ::std::os::raw::c_uint, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_int64(value: ::std::os::raw::c_longlong, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_uint64(value: ::std::os::raw::c_ulonglong, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_bool(value: bool, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_float(value: f32, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_from_double(value: f64, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_fromByteArray(value: *const QByteArray, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_fromString(value: *const QString, result: *mut QVariant);
}
extern "C" {
    pub fn qffi_QVariant_fromUtf8(
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        result: *mut QVariant,
    );
}
extern "C" {
    pub fn qffi_QVariant_toInt(self_: *const QVariant, ok: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QVariant_toUInt(self_: *const QVariant, ok: *mut bool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn qffi_QVariant_toLongLong(
        self_: *const QVariant,
        ok: *mut bool,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn qffi_QVariant_toULongLong(
        self_: *const QVariant,
        ok: *mut bool,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn qffi_QVariant_toFloat(self_: *const QVariant, ok: *mut bool) -> f32;
}
extern "C" {
    pub fn qffi_QVariant_toDouble(self_: *const QVariant, ok: *mut bool) -> f64;
}
extern "C" {
    pub fn qffi_QVariant_toBool(self_: *const QVariant) -> bool;
}
extern "C" {
    pub fn qffi_QVariant_toByteArray(self_: *const QVariant, result: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QVariant_toString(self_: *const QVariant, result: *mut QString);
}
extern "C" {
    pub fn qffi_QVariant_toUtf8(self_: *const QVariant, result: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QVariant_debug(self_: *const QVariant, result: *mut QByteArray);
}
extern "C" {
    pub fn qffi_QTimer_init(parent: *mut QObject) -> *mut QTimer;
}
extern "C" {
    pub fn qffi_QTimer_isActive(self_: *const QTimer) -> bool;
}
extern "C" {
    pub fn qffi_QTimer_interval(self_: *const QTimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QTimer_setInterval(self_: *mut QTimer, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn qffi_QTimer_remainingTime(self_: *const QTimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QTimer_isSingleShot(self_: *const QTimer) -> bool;
}
extern "C" {
    pub fn qffi_QTimer_setSingleShot(self_: *mut QTimer, value: bool);
}
extern "C" {
    pub fn qffi_QTimer_timerType(self_: *const QTimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QTimer_setTimerType(self_: *mut QTimer, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn qffi_QTimer_start(self_: *mut QTimer);
}
extern "C" {
    pub fn qffi_QTimer_startWithInterval(self_: *mut QTimer, interval: ::std::os::raw::c_int);
}
extern "C" {
    pub fn qffi_QTimer_stop(self_: *mut QTimer);
}
extern "C" {
    pub fn qffi_QCoreApplication_exec() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QCoreApplication_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> *mut QCoreApplication;
}
extern "C" {
    pub fn qffi_QGuiApplication_exec() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QGuiApplication_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> *mut QGuiApplication;
}
extern "C" {
    pub fn qffi_QHashIntQByteArray_init(self_: *mut QHashIntQByteArray);
}
extern "C" {
    pub fn qffi_QHashIntQByteArray_clone(
        self_: *const QHashIntQByteArray,
        new_: *mut QHashIntQByteArray,
    );
}
extern "C" {
    pub fn qffi_QHashIntQByteArray_equals(
        self_: *const QHashIntQByteArray,
        other: *const QHashIntQByteArray,
    ) -> bool;
}
extern "C" {
    pub fn qffi_QHashIntQByteArray_size(self_: *const QHashIntQByteArray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QHashIntQByteArray_insert(
        self_: *mut QHashIntQByteArray,
        key: *const ::std::os::raw::c_int,
        value: *const QByteArray,
    );
}
extern "C" {
    pub fn qffi_QQmlApplicationEngine_init(parent: *mut QObject) -> *mut QQmlApplicationEngine;
}
extern "C" {
    pub fn qffi_QQmlApplicationEngine_load(self_: *mut QQmlApplicationEngine, url: *const QUrl);
}
extern "C" {
    pub fn qffi_QQmlApplicationEngine_rootObjects(
        self_: *mut QQmlApplicationEngine,
        result: *mut QObjectList,
    );
}
extern "C" {
    pub fn qffi_QObjectList_init(self_: *mut QObjectList);
}
extern "C" {
    pub fn qffi_QObjectList_clone(self_: *const QObjectList, new_: *mut QObjectList);
}
extern "C" {
    pub fn qffi_QObjectList_equals(self_: *const QObjectList, other: *const QObjectList) -> bool;
}
extern "C" {
    pub fn qffi_QObjectList_size(self_: *const QObjectList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QObjectList_asSlice(
        self_: *const QObjectList,
        size: *mut ::std::os::raw::c_int,
    ) -> *const *mut QObject;
}
extern "C" {
    pub fn qffi_QObjectList_append(self_: *mut QObjectList, item: *const *mut QObject);
}
extern "C" {
    pub fn qffi_QObjectList_appendList(self_: *mut QObjectList, item: *const QList);
}
extern "C" {
    pub fn qffi_QObjectList_appendSlice(
        self_: *mut QObjectList,
        items: *const *mut QObject,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn qffi_QObjectList_reserveAdditional(
        self_: *mut QObjectList,
        additional: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn qffi_QStringList_init(self_: *mut QStringList);
}
extern "C" {
    pub fn qffi_QStringList_clone(self_: *const QStringList, new_: *mut QStringList);
}
extern "C" {
    pub fn qffi_QStringList_equals(self_: *const QStringList, other: *const QStringList) -> bool;
}
extern "C" {
    pub fn qffi_QStringList_size(self_: *const QStringList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qffi_QStringList_asSlice(
        self_: *const QStringList,
        size: *mut ::std::os::raw::c_int,
    ) -> *const QString;
}
extern "C" {
    pub fn qffi_QStringList_append(self_: *mut QStringList, item: *const QString);
}
extern "C" {
    pub fn qffi_QStringList_appendList(self_: *mut QStringList, item: *const QList);
}
extern "C" {
    pub fn qffi_QStringList_appendSlice(
        self_: *mut QStringList,
        items: *const QString,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn qffi_QStringList_reserveAdditional(
        self_: *mut QStringList,
        additional: ::std::os::raw::c_int,
    );
}
